
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="저장하고 까먹자">
    <title>동시성 이슈와 Redis( Redisson )를 이용한 해결방법 - 저장하고 까먹자</title>
    <meta name="author" content="Junggu Ji">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Junggu Ji","sameAs":["https://github.com/jungguji","mailto"]},"articleBody":"도입동시성 제어는 여러 사용자가 동시에 시스템을 사용할 때 발생할 수 있는 데이터 무결성과 성능 문제를 해결하는 데 중요한 역할을 한다. 본 글은 Redis와 Redisson 라이브러리를 활용하여 분산 환경에서 발생하는 동시성 이슈를 해결하기 위한 방안을 탐구하고자 한다. 본 글에서는 사내에서 발생했던 동시성 문제와 비슷한 상황을 예시 코드로 재현하여 문제를 정의하고, 이를 해결하기 위한 방법을 설명한다.\n\n이론적 배경\n동시성 제어와 분산 락의 중요성\n동시성 이슈는 분산 환경에서 동일한 데이터에 여러 프로세스가 동시에 접근할 때 발생한다. 이를 해결하기 위해 락(lock) 메커니즘이 널리 사용된다.\n일반적인 락(mutex lock, spin lock 등)은 단일 시스템 내에서만 작동하며, 분산 락은 여러 시스템 간의 경쟁 상태를 관리한다.\n단일 시스템의 예로는 하나의 WAS(Tomcat)에서 실행되는 애플리케이션이 있고, 이 환경에서는 스레드 간의 동기화가 주로 필요하다.\n여러 시스템의 예로는 여러 개의 WAS(Tomcat) 인스턴스가 로드 밸런서를 통해 분산 처리하는 환경이 있으며, 이러한 경우 서버 간 데이터 동기화를 위한 분산 락이 필요하다.\n\n\n\n\n\n\nRedis와 Redisson\nRedis는 인메모리 데이터베이스로 높은 처리 속도와 다양한 데이터 구조를 지원한다. 이를 활용한 분산 락 구현은 효율적인 동시성 제어를 제공한다.\nRedisson은 Redis 클라이언트 라이브러리로, 분산 락을 포함한 다양한 동시성 제어 기능을 제공한다.\n\n\n\n연구방법1. 문제 정의\n\n챗봇 대화 서비스를 운영중이었고, 유저가 챗봇과 대화 시 대화에 필요한 서비스 내 재화가 소모 되는 방식이었다.\n서버 구조는 다음과 같았다:     \n메시지큐를 이용해 채팅 서버로 메시지를 전달하고, 답장 서버에서 답장을 메시지큐를 통해 다시 수신하여 처리하는 구조였다.\n답장 서버는 8대가 운영 중이었고, 유저는 동시에 여러 챗봇과 대화가 가능했다.\n메시지큐에 동일한 유저가 여러 챗봇과의 대화를 진행하며 생성된 메시지가 각각 저장되고, 여러 서버에서 이러한 메시지를 동시에 처리하면서 동시성 문제가 발생하여, 유저가 소비해야 하는 재화가 올바르게 차감되지 않는 현상이 나타났다.\n이를 재현하기 위해 아래와 같은 코드를 작성하여 실험을 설계하였다.\n\n\n\n2. 실험 설계\n\n문제를 재현하기 위해 아래 코드를 작성하여 실험을 설계하였다.123456789101112131415public ResponseEntity&lt;String&gt; consumeResource(int userId) &#123;     Optional&lt;User&gt; userOpt = resourceRepository.findById(userId);     try &#123;         Thread.sleep(100); // 로직 수행에 100ms가 걸린다고 가정하고, 100ms 지연     &#125; catch (InterruptedException e) &#123;         Thread.currentThread().interrupt();     &#125;     User user = userOpt.get();     user.consumeResource(1);     resourceRepository.save(user);     log.info(&quot;User &#123;&#125; 자원 1 사용, 남은 자원: &#123;&#125;&quot;, userId, user.getRemainingResources());     return ResponseEntity.ok(&quot;자원 소비. 남은 자원: &quot; + user.getRemainingResources()); &#125;\n\n자원 소비 중 동시성 문제가 발생하는 현상을 확인하기 위한 예시 코드로, 여러 스레드에서 동일한 유저의 데이터를 동시에 처리할 경우 재화가 예상보다 적게 차감되는 동작을 확인하였다.\n이 코드는 단일 시스템에서 동작하는 코드로, 분산 락이 아닌 일반적인 락으로도 해결할 수 있는 상황이다. 하지만 실제 문제와 동일하게 여러 스레드나 서버가 하나의 자원에 동시 접근하는 상황을 재현할 수 있으므로, 실험 결과의 신뢰성에는 문제가 없을 것으로 보인다.\n\n\n\n2.1. 실험 결과\n\nwrk를 사용하여 동일 자원에 대해 다수의 요청을 보냈으며, 다음과 같은 결과가 확인되었다.\n\n\n테스트에 사용된 lua script\n 1234567891011121314-- 요청 수 제한local max_requests = 10 -- 요청 수 제한local request_count = 0 -- 현재 요청 수request = function()   if request_count &gt;= max_requests then      wrk.thread:stop() -- 요청 제한에 도달하면 쓰레드 중지   end   request_count = request_count + 1   local user_id = 1   local path = &quot;/resources/&quot; .. user_id .. &quot;/consume&quot;   return wrk.format(&quot;POST&quot;, path)end\n\n실험 명령어: 1wrk -t5 -c20 -d1s -s test_consume.lua http://localhost:8080\n실험 결과 요약:\n로그에서 동일 자원에 대해 여러 요청이 동시에 처리되며 자원의 남은 개수가 정확히 감소하지 않는 현상이 나타났다.\n이는 요청 간 자원 상태가 정확히 반영되지 않고 동일한 초기 상태로 처리된 결과이다.\n예를 들어, 로그에서 “User 1 자원 1 사용, 남은 자원: 9”가 반복 출력되었으며, 이후 일부 요청만 자원이 감소된 상태를 올바르게 반영하였다.\n\n\n문제 분석:\n요청이 짧은 시간에 집중적으로 발생하며, 트랜잭션 커밋이 완료되기 전에 다른 요청이 동일 자원의 상태를 조회하고 처리하였다.\n이러한 동시성 이슈는 예시 코드에서 자원 접근 시 락을 사용하지 않았기 때문에 발생한 것으로 보인다.\n결과적으로, 여러 요청이 자원을 중복해서 처리하며 데이터의 무결성이 훼손되었다.\n\n\n\n3. 문제 해결\n\n분산 락 설계:\n\nRedisson의 tryLock 메서드를 활용하여 특정 리소스에 대한 락을 획득한다.\n락 획득에 실패한 요청은 대기하거나 재시도하도록 구현한다.12345678910111213141516171819202122@PostMapping(&quot;&#123;userId&#125;/consume&quot;)public ResponseEntity&lt;String&gt; consumeResource(@PathVariable(&quot;userId&quot;) int userId) &#123;   String lockName = &quot;user:&quot; + userId + &quot;:resource:lock&quot;;   RLock lock = redissonClient.getLock(lockName);   int remainingResources = 0;   try &#123;         boolean isLocked = lock.tryLock(3, 10, TimeUnit.SECONDS);         if (isLocked) &#123;            remainingResources = resourceService.consumeResource(userId);         &#125;   &#125; catch (RuntimeException | InterruptedException e) &#123;         throw new RuntimeException(&quot;Lock 획득 실패&quot;, e);   &#125; finally &#123;         if (lock.isHeldByCurrentThread()) &#123; // 락 소유 여부 확인            lock.unlock();         &#125;   &#125;   return ResponseEntity.ok(&quot;자원 소비. 남은 자원: &quot; + remainingResources);&#125;\n\n\n락 해제 매커니즘: Redisson 내부적으로 락을 관리하고 해제하는 메커니즘은 Redis Pub/Sub 시스템과 AsyncSemaphore를 활용하여 다음과 같은 방식으로 동작한다:\n \n    Redisson tryLock() Code\n       12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;   long time = unit.toMillis(waitTime);   long current = System.currentTimeMillis();   long threadId = Thread.currentThread().getId();   // 1. 최초 락 획득 시도   Long ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId);   if (ttl == null) &#123;         return true;   &#125; else &#123;         // 2. 타이머 갱신 및 대기         time -= System.currentTimeMillis() - current;         if (time &lt;= 0L) &#123;            this.acquireFailed(waitTime, unit, threadId);            return false;         &#125; else &#123;            current = System.currentTimeMillis();            // 3. Pub/Sub 채널 구독            CompletableFuture&lt;RedissonLockEntry&gt; subscribeFuture = this.subscribe(threadId);            try &#123;               subscribeFuture.get(time, TimeUnit.MILLISECONDS);            &#125; catch (TimeoutException var21) &#123;               if (!subscribeFuture.completeExceptionally(new RedisTimeoutException(&quot;Unable to acquire subscription lock after &quot; + time + &quot;ms. Try to increase &#x27;subscriptionsPerConnection&#x27; and/or &#x27;subscriptionConnectionPoolSize&#x27; parameters.&quot;))) &#123;                     subscribeFuture.whenComplete((res, ex) -&gt; &#123;                        if (ex == null) &#123;                           this.unsubscribe(res, threadId);                        &#125;                     &#125;);               &#125;               this.acquireFailed(waitTime, unit, threadId);               return false;            &#125; catch (ExecutionException var22) &#123;               ExecutionException e = var22;               LOGGER.error(e.getMessage(), e);               this.acquireFailed(waitTime, unit, threadId);               return false;            &#125;            try &#123;               time -= System.currentTimeMillis() - current;               if (time &lt;= 0L) &#123;                     this.acquireFailed(waitTime, unit, threadId);                     boolean var25 = false;                     return var25;               &#125; else &#123;                     boolean var16;                     do &#123;                        long currentTime = System.currentTimeMillis();                        ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId);                        if (ttl == null) &#123;                           var16 = true;                           return var16;                        &#125;                        time -= System.currentTimeMillis() - currentTime;                        if (time &lt;= 0L) &#123;                           this.acquireFailed(waitTime, unit, threadId);                           var16 = false;                           return var16;                        &#125;                                                // 4. Latch 대기와 재시도                        currentTime = System.currentTimeMillis();                        if (ttl &gt;= 0L &amp;&amp; ttl &lt; time) &#123;                           ((RedissonLockEntry)this.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);                        &#125; else &#123;                           ((RedissonLockEntry)this.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);                        &#125;                        time -= System.currentTimeMillis() - currentTime;                     &#125; while(time &gt; 0L);                     this.acquireFailed(waitTime, unit, threadId);                     var16 = false;                     return var16;               &#125;            &#125; finally &#123;               // 5. 구독 해제               this.unsubscribe((RedissonLockEntry)this.commandExecutor.getNow(subscribeFuture), threadId);            &#125;         &#125;   &#125;&#125;\n    \n\n 1. 최초 락 획득 시도\n\ntryAcquire 메서드를 통해 락 획득 가능 여부를 확인하며, null을 반환하면 현재 락을 바로 획득할 수 있음을 의미한다.\n락이 이미 선점된 경우, ttl(잠금의 남은 유효 시간)을 반환하여 대기할 시간을 계산한다.\n\n 2. 타이머 갱신 및 대기\n\n대기 중 경과된 시간을 waitTime에서 차감하며 남은 시간이 0 이하일 경우 대기를 종료하고 false를 반환한다.\n\n 3. Pub/Sub 채널 구독\n\n락 해제 이벤트를 감지하기 위해 Redis Pub/Sub 채널에 구독을 요청한다.\nsubscribeFuture를 통해 락이 해제되었거나 구독에 실패한 경우 작업이 비동기적으로 처리된다.\n\n 4. latch 대기와 재시도\n\nPub/Sub 채널 구독이 성공한 상태에서 tryAcquire를 반복 호출하며 락 획득을 재시도한다.\nTTL 값에 따라 latch 대기 시간이 설정되며, 다른 스레드에서 락이 해제되면 latch가 해제되어 작업이 이어진다.\n\n 5. 구독 해제\n\n락을 획득하든 못 하든 메서드를 종료하기 전에 Pub/Sub 구독 리소스를 해제하여 시스템 자원을 정리한다.\n\n\n\n3.1. Redisson 적용 후 실험 결과:\n\n2.1. 실험과 동일한 script와 wrk 명령어를 이용해 실험을 진행했으며, 다음과 같은 결과가 확인되었다.\n\n\n실험 결과 요약:\n\nRedisson을 사용하여 분산 락을 적용한 결과, 모든 요청이 순차적으로 처리되었으며 데이터의 무결성이 유지되었다.\n로그에서 확인할 수 있듯이 동일한 자원에 대해 락이 적용되어 요청이 병렬적으로 처리되지 않고 순차적으로 처리되었다.\n예를 들어, “User 1 자원 1 사용, 남은 자원: 9”에서 시작하여 요청이 처리될 때마다 자원이 정확히 감소하는 모습을 확인할 수 있었다.\n실험 중에는 잘못된 자원 감소나 동시성 문제가 발생하지 않았다.\n\n\n문제 해결 확인:\n\nRedisson의 분산 락을 적용함으로써 동시성 문제로 인한 데이터 무결성 훼손이 해결되었다.\n요청량이 많을 때에도 대기 상태로 처리되며 자원의 상태가 정확히 갱신되었다.\n\n\n\n결과\n테스트 결과\nRedisson 기반 분산 락을 적용한 후, 중복 트랜잭션 문제가 해결되었다.\n부하 테스트(wrk)에서 동일한 유저의 데이터를 처리할 때, 데이터 무결성이 유지됨을 확인하였다.\n이로써 분산 서버 환경에서 발생하던 자원 동시성 문제를 해결할 수 있었다.\n\n\n\n\n논의Pub/Sub 기반 락 메커니즘은 성능과 자원 활용면에서 유리하며, 이를 사용하는 Redisson을 사용하여 분산 환경에서도 효율적으로 동시성 제어가 가능하지만,Redis를 따로 구축하여야 한다는 점, Redis의 장애 시 락 메커니즘이 정상적으로 동작하지 않을 수 있다는 점과 락 해제 실패 또는 락 대기 시간 초과 시 추가적 오류 처리가 필요하다는 한계점 등이 존재한다.해당 한계점들을 개선하기 위해 이후에 Redis Cluster를 활용해 고가용성을 확보하여야하고, Redis 외에 기타 다른 도구(Zookeeper, Etcd 등)와의 성능 비교가 필요하다.\n결론본 글에서는 Redis와 Redisson을 활용한 분산 락 메커니즘을 통해 동시성 이슈를 해결하는 방법을 제시하였다.실험 결과, 제안된 방법은 데이터 무결성을 효과적으로 유지하며, 부하 테스트에서도 우수한 성능을 보였다.본 글이 분산 환경에서의 동시성 문제를 해결하려는 개발자들에게 실질적인 가이드라인을 제공하길 기대한다.\n","dateCreated":"2024-12-24T12:26:46+09:00","dateModified":"2024-12-24T12:26:46+09:00","datePublished":"2024-12-24T12:26:46+09:00","description":"","headline":"동시성 이슈와 Redis( Redisson )를 이용한 해결방법","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/"},"publisher":{"@type":"Organization","name":"Junggu Ji","sameAs":["https://github.com/jungguji","mailto"]},"url":"https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/","keywords":"redisson, redis, 동시성"}</script>
    <meta name="description" content="도입동시성 제어는 여러 사용자가 동시에 시스템을 사용할 때 발생할 수 있는 데이터 무결성과 성능 문제를 해결하는 데 중요한 역할을 한다. 본 글은 Redis와 Redisson 라이브러리를 활용하여 분산 환경에서 발생하는 동시성 이슈를 해결하기 위한 방안을 탐구하고자 한다. 본 글에서는 사내에서 발생했던 동시성 문제와 비슷한 상황을 예시 코드로 재현하여 문제">
<meta property="og:type" content="blog">
<meta property="og:title" content="동시성 이슈와 Redis( Redisson )를 이용한 해결방법">
<meta property="og:url" content="https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/index.html">
<meta property="og:site_name" content="저장하고 까먹자">
<meta property="og:description" content="도입동시성 제어는 여러 사용자가 동시에 시스템을 사용할 때 발생할 수 있는 데이터 무결성과 성능 문제를 해결하는 데 중요한 역할을 한다. 본 글은 Redis와 Redisson 라이브러리를 활용하여 분산 환경에서 발생하는 동시성 이슈를 해결하기 위한 방안을 탐구하고자 한다. 본 글에서는 사내에서 발생했던 동시성 문제와 비슷한 상황을 예시 코드로 재현하여 문제">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/1.png">
<meta property="og:image" content="https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/2.png">
<meta property="og:image" content="https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/4.png">
<meta property="article:published_time" content="2024-12-24T03:26:46.000Z">
<meta property="article:modified_time" content="2024-12-24T03:26:46.000Z">
<meta property="article:author" content="Junggu Ji">
<meta property="article:tag" content="redisson">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="동시성">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/1.png">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-0v3zgfakrzmjoj7mhqewlnecogoqxgnfgvjlrw6b9na0ll2gjplxm4ld0oox.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162527815-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-162527815-1');
    </script>


    

    
        
    

    <script data-ad-client="ca-pub-6264654331856753" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/" aria-label>
            저장하고 까먹자
        </a>
    </div>
    
        
            <a class="header-right-picture " href="#about" aria-label="링크 열기: /#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/" rel="noopener" title="Home">
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" rel="noopener" title="카테고리">
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" rel="noopener" title="태그">
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" rel="noopener" title="아카이브">
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" rel="noopener" title="About">
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jungguji" target="_blank" rel="external nofollow noopener noreferrer" title="GitHub">
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" rel="noopener" title="Mail">
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" rel="noopener" title="RSS">
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4" class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            동시성 이슈와 Redis( Redisson )를 이용한 해결방법
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2024-12-24T12:26:46+09:00">
	
		    2024/12/24
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h2><p>동시성 제어는 여러 사용자가 동시에 시스템을 사용할 때 발생할 수 있는 데이터 무결성과 성능 문제를 해결하는 데 중요한 역할을 한다. 본 글은 Redis와 Redisson 라이브러리를 활용하여 분산 환경에서 발생하는 동시성 이슈를 해결하기 위한 방안을 탐구하고자 한다. 본 글에서는 사내에서 발생했던 동시성 문제와 비슷한 상황을 예시 코드로 재현하여 문제를 정의하고, 이를 해결하기 위한 방법을 설명한다.</p>
<hr>
<h2 id="이론적-배경"><a href="#이론적-배경" class="headerlink" title="이론적 배경"></a>이론적 배경</h2><ol>
<li>동시성 제어와 분산 락의 중요성<ul>
<li>동시성 이슈는 분산 환경에서 동일한 데이터에 여러 프로세스가 동시에 접근할 때 발생한다. 이를 해결하기 위해 락(lock) 메커니즘이 널리 사용된다.</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/%EB%9D%BD_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">일반적인 락(mutex lock, spin lock 등)</a>은 단일 시스템 내에서만 작동하며, 분산 락은 여러 시스템 간의 경쟁 상태를 관리한다.<ul>
<li>단일 시스템의 예로는 하나의 WAS(Tomcat)에서 실행되는 애플리케이션이 있고, 이 환경에서는 스레드 간의 동기화가 주로 필요하다.</li>
<li>여러 시스템의 예로는 여러 개의 WAS(Tomcat) 인스턴스가 로드 밸런서를 통해 분산 처리하는 환경이 있으며, 이러한 경우 서버 간 데이터 동기화를 위한 분산 락이 필요하다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>Redis와 Redisson<ul>
<li>Redis는 인메모리 데이터베이스로 높은 처리 속도와 다양한 데이터 구조를 지원한다. 이를 활용한 분산 락 구현은 효율적인 동시성 제어를 제공한다.</li>
<li>Redisson은 Redis 클라이언트 라이브러리로, 분산 락을 포함한 다양한 동시성 제어 기능을 제공한다.</li>
</ul>
</li>
</ol>
<h2 id="연구방법"><a href="#연구방법" class="headerlink" title="연구방법"></a>연구방법</h2><p><strong>1. 문제 정의</strong></p>
<ul>
<li>챗봇 대화 서비스를 운영중이었고, 유저가 챗봇과 대화 시 대화에 필요한 서비스 내 재화가 소모 되는 방식이었다.</li>
<li>서버 구조는 다음과 같았다:     <ul>
<li>메시지큐를 이용해 채팅 서버로 메시지를 전달하고, 답장 서버에서 답장을 메시지큐를 통해 다시 수신하여 처리하는 구조였다.<img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/1.png" class></li>
<li>답장 서버는 8대가 운영 중이었고, 유저는 동시에 여러 챗봇과 대화가 가능했다.</li>
<li>메시지큐에 동일한 유저가 여러 챗봇과의 대화를 진행하며 생성된 메시지가 각각 저장되고, 여러 서버에서 이러한 메시지를 동시에 처리하면서 동시성 문제가 발생하여, 유저가 소비해야 하는 재화가 올바르게 차감되지 않는 현상이 나타났다.</li>
<li>이를 재현하기 위해 아래와 같은 코드를 작성하여 실험을 설계하였다.</li>
</ul>
</li>
</ul>
<p><strong>2. 실험 설계</strong></p>
<ul>
<li>문제를 재현하기 위해 아래 코드를 작성하여 실험을 설계하였다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">consumeResource</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">     Optional&lt;User&gt; userOpt = resourceRepository.findById(userId);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>); <span class="comment">// 로직 수행에 100ms가 걸린다고 가정하고, 100ms 지연</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         Thread.currentThread().interrupt();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     User user = userOpt.get();</span><br><span class="line">     user.consumeResource(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     resourceRepository.save(user);</span><br><span class="line">     log.info(<span class="string">&quot;User &#123;&#125; 자원 1 사용, 남은 자원: &#123;&#125;&quot;</span>, userId, user.getRemainingResources());</span><br><span class="line">     <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;자원 소비. 남은 자원: &quot;</span> + user.getRemainingResources());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자원 소비 중 동시성 문제가 발생하는 현상을 확인하기 위한 예시 코드로, 여러 스레드에서 동일한 유저의 데이터를 동시에 처리할 경우 재화가 예상보다 적게 차감되는 동작을 확인하였다.</li>
<li>이 코드는 단일 시스템에서 동작하는 코드로, 분산 락이 아닌 일반적인 락으로도 해결할 수 있는 상황이다. 하지만 실제 문제와 동일하게 여러 스레드나 서버가 하나의 자원에 동시 접근하는 상황을 재현할 수 있으므로, 실험 결과의 신뢰성에는 문제가 없을 것으로 보인다.</li>
</ul>
</li>
</ul>
<p><strong>2.1. 실험 결과</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wg/wrk">wrk</a>를 사용하여 동일 자원에 대해 다수의 요청을 보냈으며, 다음과 같은 결과가 확인되었다.</li>
<li><img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/2.png" class></li>
<li><details>
<summary>테스트에 사용된 lua script</summary>
 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 요청 수 제한</span></span><br><span class="line"><span class="keyword">local</span> max_requests = <span class="number">10</span> <span class="comment">-- 요청 수 제한</span></span><br><span class="line"><span class="keyword">local</span> request_count = <span class="number">0</span> <span class="comment">-- 현재 요청 수</span></span><br><span class="line"></span><br><span class="line">request = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">if</span> request_count &gt;= max_requests <span class="keyword">then</span></span><br><span class="line">      wrk.thread:stop() <span class="comment">-- 요청 제한에 도달하면 쓰레드 중지</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   request_count = request_count + <span class="number">1</span></span><br><span class="line">   <span class="keyword">local</span> user_id = <span class="number">1</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/resources/&quot;</span> .. user_id .. <span class="string">&quot;/consume&quot;</span></span><br><span class="line">   <span class="keyword">return</span> wrk.<span class="built_in">format</span>(<span class="string">&quot;POST&quot;</span>, <span class="built_in">path</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</details></li>
<li><strong>실험 명령어:</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t5 -c20 -d1s -s test_consume.lua http://localhost:8080</span><br></pre></td></tr></table></figure></li>
<li><strong>실험 결과 요약:</strong><ul>
<li>로그에서 동일 자원에 대해 여러 요청이 동시에 처리되며 자원의 남은 개수가 정확히 감소하지 않는 현상이 나타났다.</li>
<li>이는 요청 간 자원 상태가 정확히 반영되지 않고 동일한 초기 상태로 처리된 결과이다.</li>
<li>예를 들어, 로그에서 “User 1 자원 1 사용, 남은 자원: 9”가 반복 출력되었으며, 이후 일부 요청만 자원이 감소된 상태를 올바르게 반영하였다.</li>
</ul>
</li>
<li><strong>문제 분석:</strong><ul>
<li>요청이 짧은 시간에 집중적으로 발생하며, 트랜잭션 커밋이 완료되기 전에 다른 요청이 동일 자원의 상태를 조회하고 처리하였다.</li>
<li>이러한 동시성 이슈는 예시 코드에서 자원 접근 시 락을 사용하지 않았기 때문에 발생한 것으로 보인다.</li>
<li>결과적으로, 여러 요청이 자원을 중복해서 처리하며 데이터의 무결성이 훼손되었다.</li>
</ul>
</li>
</ul>
<p><strong>3. 문제 해결</strong></p>
<ul>
<li><p><strong>분산 락 설계:</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://redisson.org/docs/data-and-services/locks-and-synchronizers/#lock">Redisson</a>의 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RLock.html">tryLock</a> 메서드를 활용하여 특정 리소스에 대한 락을 획득한다.</li>
<li>락 획득에 실패한 요청은 대기하거나 재시도하도록 구현한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;&#123;userId&#125;/consume&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">consumeResource</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   String lockName = <span class="string">&quot;user:&quot;</span> + userId + <span class="string">&quot;:resource:lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">   RLock lock = redissonClient.getLock(lockName);</span><br><span class="line">   <span class="keyword">int</span> remainingResources = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> isLocked = lock.tryLock(<span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">            remainingResources = resourceService.consumeResource(userId);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RuntimeException | InterruptedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Lock 획득 실패&quot;</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123; <span class="comment">// 락 소유 여부 확인</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;자원 소비. 남은 자원: &quot;</span> + remainingResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>락 해제 매커니즘:</strong><br> Redisson 내부적으로 락을 관리하고 해제하는 메커니즘은 Redis Pub/Sub 시스템과 AsyncSemaphore를 활용하여 다음과 같은 방식으로 동작한다:</p>
 <details>
    <summary>Redisson tryLock() Code</summary>
       <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">   <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 1. 최초 락 획득 시도</span></span><br><span class="line">   Long ttl = <span class="keyword">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">   <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 2. 타이머 갱신 및 대기</span></span><br><span class="line">         time -= System.currentTimeMillis() - current;</span><br><span class="line">         <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 3. Pub/Sub 채널 구독</span></span><br><span class="line">            CompletableFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="keyword">this</span>.subscribe(threadId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               subscribeFuture.get(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException var21) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!subscribeFuture.completeExceptionally(<span class="keyword">new</span> RedisTimeoutException(<span class="string">&quot;Unable to acquire subscription lock after &quot;</span> + time + <span class="string">&quot;ms. Try to increase &#x27;subscriptionsPerConnection&#x27; and/or &#x27;subscriptionConnectionPoolSize&#x27; parameters.&quot;</span>))) &#123;</span><br><span class="line">                     subscribeFuture.whenComplete((res, ex) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.unsubscribe(res, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     &#125;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException var22) &#123;</span><br><span class="line">               ExecutionException e = var22;</span><br><span class="line">               LOGGER.error(e.getMessage(), e);</span><br><span class="line">               <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               time -= System.currentTimeMillis() - current;</span><br><span class="line">               <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                     <span class="keyword">boolean</span> var25 = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">return</span> var25;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">boolean</span> var16;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">                        ttl = <span class="keyword">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           var16 = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">return</span> var16;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                           var16 = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="keyword">return</span> var16;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 4. Latch 대기와 재시도</span></span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                           ((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           ((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                     &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                     var16 = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">return</span> var16;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 5. 구독 해제</span></span><br><span class="line">               <span class="keyword">this</span>.unsubscribe((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture), threadId);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </details>

<p> <strong>1. 최초 락 획득 시도</strong></p>
<ul>
<li>tryAcquire 메서드를 통해 락 획득 가능 여부를 확인하며, null을 반환하면 현재 락을 바로 획득할 수 있음을 의미한다.</li>
<li>락이 이미 선점된 경우, ttl(잠금의 남은 유효 시간)을 반환하여 대기할 시간을 계산한다.</li>
</ul>
<p> <strong>2. 타이머 갱신 및 대기</strong></p>
<ul>
<li>대기 중 경과된 시간을 waitTime에서 차감하며 남은 시간이 0 이하일 경우 대기를 종료하고 false를 반환한다.</li>
</ul>
<p> <strong>3. Pub/Sub 채널 구독</strong></p>
<ul>
<li>락 해제 이벤트를 감지하기 위해 Redis Pub/Sub 채널에 구독을 요청한다.</li>
<li>subscribeFuture를 통해 락이 해제되었거나 구독에 실패한 경우 작업이 비동기적으로 처리된다.</li>
</ul>
<p> <strong>4. latch 대기와 재시도</strong></p>
<ul>
<li>Pub/Sub 채널 구독이 성공한 상태에서 tryAcquire를 반복 호출하며 락 획득을 재시도한다.</li>
<li>TTL 값에 따라 latch 대기 시간이 설정되며, 다른 스레드에서 락이 해제되면 latch가 해제되어 작업이 이어진다.</li>
</ul>
<p> <strong>5. 구독 해제</strong></p>
<ul>
<li>락을 획득하든 못 하든 메서드를 종료하기 전에 Pub/Sub 구독 리소스를 해제하여 시스템 자원을 정리한다.</li>
</ul>
</li>
</ul>
<p><strong>3.1. Redisson 적용 후 실험 결과:</strong></p>
<ul>
<li><p>2.1. 실험과 동일한 script와 wrk 명령어를 이용해 실험을 진행했으며, 다음과 같은 결과가 확인되었다.</p>
</li>
<li><img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/4.png" class></li>
<li><p><strong>실험 결과 요약:</strong></p>
<ul>
<li>Redisson을 사용하여 분산 락을 적용한 결과, 모든 요청이 순차적으로 처리되었으며 데이터의 무결성이 유지되었다.</li>
<li>로그에서 확인할 수 있듯이 동일한 자원에 대해 락이 적용되어 요청이 병렬적으로 처리되지 않고 순차적으로 처리되었다.</li>
<li>예를 들어, “User 1 자원 1 사용, 남은 자원: 9”에서 시작하여 요청이 처리될 때마다 자원이 정확히 감소하는 모습을 확인할 수 있었다.</li>
<li>실험 중에는 잘못된 자원 감소나 동시성 문제가 발생하지 않았다.</li>
</ul>
</li>
<li><p><strong>문제 해결 확인:</strong></p>
<ul>
<li>Redisson의 분산 락을 적용함으로써 동시성 문제로 인한 데이터 무결성 훼손이 해결되었다.</li>
<li>요청량이 많을 때에도 대기 상태로 처리되며 자원의 상태가 정확히 갱신되었다.</li>
</ul>
</li>
</ul>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>테스트 결과<ul>
<li>Redisson 기반 분산 락을 적용한 후, 중복 트랜잭션 문제가 해결되었다.</li>
<li>부하 테스트(wrk)에서 동일한 유저의 데이터를 처리할 때, 데이터 무결성이 유지됨을 확인하였다.</li>
<li>이로써 분산 서버 환경에서 발생하던 자원 동시성 문제를 해결할 수 있었다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="논의"><a href="#논의" class="headerlink" title="논의"></a>논의</h2><p>Pub/Sub 기반 락 메커니즘은 성능과 자원 활용면에서 유리하며, 이를 사용하는 Redisson을 사용하여 분산 환경에서도 효율적으로 동시성 제어가 가능하지만,<br>Redis를 따로 구축하여야 한다는 점, Redis의 장애 시 락 메커니즘이 정상적으로 동작하지 않을 수 있다는 점과 락 해제 실패 또는 락 대기 시간 초과 시 추가적 오류 처리가 필요하다는 한계점 등이 존재한다.<br>해당 한계점들을 개선하기 위해 이후에 Redis Cluster를 활용해 고가용성을 확보하여야하고, Redis 외에 기타 다른 도구(Zookeeper, Etcd 등)와의 성능 비교가 필요하다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>본 글에서는 Redis와 Redisson을 활용한 분산 락 메커니즘을 통해 동시성 이슈를 해결하는 방법을 제시하였다.<br>실험 결과, 제안된 방법은 데이터 무결성을 효과적으로 유지하며, 부하 테스트에서도 우수한 성능을 보였다.<br>본 글이 분산 환경에서의 동시성 문제를 해결하려는 개발자들에게 실질적인 가이드라인을 제공하길 기대한다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/redis/" rel="tag">redis</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/redisson/" rel="tag">redisson</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/" rel="tag">동시성</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled" aria-hidden="true">
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2024/11/19/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%EC%9D%84-%EB%8D%94-%EC%89%BD%EA%B2%8C-with-Fixture-Monkey/" data-tooltip="테스트 코드 작성을 더 쉽게 (with. Fixture Monkey)" aria-label="다음: 테스트 코드 작성을 더 쉽게 (with. Fixture Monkey)">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <script src="https://utteranc.es/client.js" repo="jungguji/blog-comment" issue-term="og:title" theme="github-light" crossorigin="anonymous" async>
</script>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Junggu Ji. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled" aria-hidden="true">
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2024/11/19/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%EC%9D%84-%EB%8D%94-%EC%89%BD%EA%B2%8C-with-Fixture-Monkey/" data-tooltip="테스트 코드 작성을 더 쉽게 (with. Fixture Monkey)" aria-label="다음: 테스트 코드 작성을 더 쉽게 (with. Fixture Monkey)">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="이 포스트 공유하기">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Facebook에 공유하기" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://twitter.com/intent/tweet?text=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Twitter에 공유하기" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="_blank" href="https://plus.google.com/share?url=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" title="Google+에 공유하기" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" aria-label="Facebook에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://twitter.com/intent/tweet?text=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" aria-label="Twitter에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="_blank" href="https://plus.google.com/share?url=https://jungguji.github.io/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" aria-label="Google+에 공유하기" rel="external nofollow noopener noreferrer">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Junggu Ji</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-goamtf3h90u4wvmhg5penagquqoptje05tyii1tz44r8vwvh6klg97rf1weo.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
