
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Junggu Ji, 생각의 기록">
    <title>태그: 동시성 - Junggu Ji, 생각의 기록</title>
    <meta name="author" content="Junggu Ji">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Junggu Ji, 생각의 기록">
<meta property="og:url" content="https://jungguji.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/index.html">
<meta property="og:site_name" content="Junggu Ji, 생각의 기록">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="Junggu Ji">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-vaqxmiojfeym1obe22l4wzlc2exrxuyy1hezfoyofzx2ow3vxa49a2skiig7.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162527815-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-162527815-1');
    </script>


    

    

    <script data-ad-client="ca-pub-6264654331856753" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/" aria-label>
            Junggu Ji, 생각의 기록
        </a>
    </div>
    
        
            <a class="header-right-picture " href="#about" aria-label="링크 열기: /#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/" rel="noopener" title="Home">
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" rel="noopener" title="카테고리">
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" rel="noopener" title="태그">
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" rel="noopener" title="아카이브">
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" rel="noopener" title="About">
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jungguji" target="_blank" rel="external nofollow noopener noreferrer" title="GitHub">
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" rel="noopener" title="Mail">
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" rel="noopener" title="RSS">
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1" class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/" aria-label=": 동시성 이슈와 Redis( Redisson )를 이용한 해결방법">
                            동시성 이슈와 Redis( Redisson )를 이용한 해결방법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2024-12-24T12:26:46+09:00">
	
		    2024/12/24
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h2><p>동시성 제어는 여러 사용자가 동시에 시스템을 사용할 때 발생할 수 있는 데이터 무결성과 성능 문제를 해결하는 데 중요한 역할을 한다. 본 글은 Redis와 Redisson 라이브러리를 활용하여 분산 환경에서 발생하는 동시성 이슈를 해결하기 위한 방안을 탐구하고자 한다. 본 글에서는 사내에서 발생했던 동시성 문제와 비슷한 상황을 예시 코드로 재현하여 문제를 정의하고, 이를 해결하기 위한 방법을 설명한다.</p>
<hr>
<h2 id="이론적-배경"><a href="#이론적-배경" class="headerlink" title="이론적 배경"></a>이론적 배경</h2><ol>
<li>동시성 제어와 분산 락의 중요성<ul>
<li>동시성 이슈는 분산 환경에서 동일한 데이터에 여러 프로세스가 동시에 접근할 때 발생한다. 이를 해결하기 위해 락(lock) 메커니즘이 널리 사용된다.</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/%EB%9D%BD_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">일반적인 락(mutex lock, spin lock 등)</a>은 단일 시스템 내에서만 작동하며, 분산 락은 여러 시스템 간의 경쟁 상태를 관리한다.<ul>
<li>단일 시스템의 예로는 하나의 WAS(Tomcat)에서 실행되는 애플리케이션이 있고, 이 환경에서는 스레드 간의 동기화가 주로 필요하다.</li>
<li>여러 시스템의 예로는 여러 개의 WAS(Tomcat) 인스턴스가 로드 밸런서를 통해 분산 처리하는 환경이 있으며, 이러한 경우 서버 간 데이터 동기화를 위한 분산 락이 필요하다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>Redis와 Redisson<ul>
<li>Redis는 인메모리 데이터베이스로 높은 처리 속도와 다양한 데이터 구조를 지원한다. 이를 활용한 분산 락 구현은 효율적인 동시성 제어를 제공한다.</li>
<li>Redisson은 Redis 클라이언트 라이브러리로, 분산 락을 포함한 다양한 동시성 제어 기능을 제공한다.</li>
</ul>
</li>
</ol>
<h2 id="연구방법"><a href="#연구방법" class="headerlink" title="연구방법"></a>연구방법</h2><p><strong>1. 문제 정의</strong></p>
<ul>
<li>챗봇 대화 서비스를 운영중이었고, 유저가 챗봇과 대화 시 대화에 필요한 서비스 내 재화가 소모 되는 방식이었다.</li>
<li>서버 구조는 다음과 같았다:     <ul>
<li>메시지큐를 이용해 채팅 서버로 메시지를 전달하고, 답장 서버에서 답장을 메시지큐를 통해 다시 수신하여 처리하는 구조였다.<img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/1.png" class></li>
<li>답장 서버는 8대가 운영 중이었고, 유저는 동시에 여러 챗봇과 대화가 가능했다.</li>
<li>메시지큐에 동일한 유저가 여러 챗봇과의 대화를 진행하며 생성된 메시지가 각각 저장되고, 여러 서버에서 이러한 메시지를 동시에 처리하면서 동시성 문제가 발생하여, 유저가 소비해야 하는 재화가 올바르게 차감되지 않는 현상이 나타났다.</li>
<li>이를 재현하기 위해 아래와 같은 코드를 작성하여 실험을 설계하였다.</li>
</ul>
</li>
</ul>
<p><strong>2. 실험 설계</strong></p>
<ul>
<li>문제를 재현하기 위해 아래 코드를 작성하여 실험을 설계하였다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">consumeResource</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">     Optional&lt;User&gt; userOpt = resourceRepository.findById(userId);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>); <span class="comment">// 로직 수행에 100ms가 걸린다고 가정하고, 100ms 지연</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         Thread.currentThread().interrupt();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     User user = userOpt.get();</span><br><span class="line">     user.consumeResource(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     resourceRepository.save(user);</span><br><span class="line">     log.info(<span class="string">&quot;User &#123;&#125; 자원 1 사용, 남은 자원: &#123;&#125;&quot;</span>, userId, user.getRemainingResources());</span><br><span class="line">     <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;자원 소비. 남은 자원: &quot;</span> + user.getRemainingResources());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자원 소비 중 동시성 문제가 발생하는 현상을 확인하기 위한 예시 코드로, 여러 스레드에서 동일한 유저의 데이터를 동시에 처리할 경우 재화가 예상보다 적게 차감되는 동작을 확인하였다.</li>
<li>이 코드는 단일 시스템에서 동작하는 코드로, 분산 락이 아닌 일반적인 락으로도 해결할 수 있는 상황이다. 하지만 실제 문제와 동일하게 여러 스레드나 서버가 하나의 자원에 동시 접근하는 상황을 재현할 수 있으므로, 실험 결과의 신뢰성에는 문제가 없을 것으로 보인다.</li>
</ul>
</li>
</ul>
<p><strong>2.1. 실험 결과</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wg/wrk">wrk</a>를 사용하여 동일 자원에 대해 다수의 요청을 보냈으며, 다음과 같은 결과가 확인되었다.</li>
<li><img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/2.png" class></li>
<li><details>
<summary>테스트에 사용된 lua script</summary>
 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 요청 수 제한</span></span><br><span class="line"><span class="keyword">local</span> max_requests = <span class="number">10</span> <span class="comment">-- 요청 수 제한</span></span><br><span class="line"><span class="keyword">local</span> request_count = <span class="number">0</span> <span class="comment">-- 현재 요청 수</span></span><br><span class="line"></span><br><span class="line">request = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">if</span> request_count &gt;= max_requests <span class="keyword">then</span></span><br><span class="line">      wrk.thread:stop() <span class="comment">-- 요청 제한에 도달하면 쓰레드 중지</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   request_count = request_count + <span class="number">1</span></span><br><span class="line">   <span class="keyword">local</span> user_id = <span class="number">1</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/resources/&quot;</span> .. user_id .. <span class="string">&quot;/consume&quot;</span></span><br><span class="line">   <span class="keyword">return</span> wrk.<span class="built_in">format</span>(<span class="string">&quot;POST&quot;</span>, <span class="built_in">path</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</details></li>
<li><strong>실험 명령어:</strong> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t5 -c20 -d1s -s test_consume.lua http://localhost:8080</span><br></pre></td></tr></table></figure></li>
<li><strong>실험 결과 요약:</strong><ul>
<li>로그에서 동일 자원에 대해 여러 요청이 동시에 처리되며 자원의 남은 개수가 정확히 감소하지 않는 현상이 나타났다.</li>
<li>이는 요청 간 자원 상태가 정확히 반영되지 않고 동일한 초기 상태로 처리된 결과이다.</li>
<li>예를 들어, 로그에서 “User 1 자원 1 사용, 남은 자원: 9”가 반복 출력되었으며, 이후 일부 요청만 자원이 감소된 상태를 올바르게 반영하였다.</li>
</ul>
</li>
<li><strong>문제 분석:</strong><ul>
<li>요청이 짧은 시간에 집중적으로 발생하며, 트랜잭션 커밋이 완료되기 전에 다른 요청이 동일 자원의 상태를 조회하고 처리하였다.</li>
<li>이러한 동시성 이슈는 예시 코드에서 자원 접근 시 락을 사용하지 않았기 때문에 발생한 것으로 보인다.</li>
<li>결과적으로, 여러 요청이 자원을 중복해서 처리하며 데이터의 무결성이 훼손되었다.</li>
</ul>
</li>
</ul>
<p><strong>3. 문제 해결</strong></p>
<ul>
<li><p><strong>분산 락 설계:</strong></p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://redisson.org/docs/data-and-services/locks-and-synchronizers/#lock">Redisson</a>의 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RLock.html">tryLock</a> 메서드를 활용하여 특정 리소스에 대한 락을 획득한다.</li>
<li>락 획득에 실패한 요청은 대기하거나 재시도하도록 구현한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;&#123;userId&#125;/consume&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">consumeResource</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   String lockName = <span class="string">&quot;user:&quot;</span> + userId + <span class="string">&quot;:resource:lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">   RLock lock = redissonClient.getLock(lockName);</span><br><span class="line">   <span class="keyword">int</span> remainingResources = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> isLocked = lock.tryLock(<span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">            remainingResources = resourceService.consumeResource(userId);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RuntimeException | InterruptedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Lock 획득 실패&quot;</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123; <span class="comment">// 락 소유 여부 확인</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;자원 소비. 남은 자원: &quot;</span> + remainingResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>락 해제 매커니즘:</strong><br> Redisson 내부적으로 락을 관리하고 해제하는 메커니즘은 Redis Pub/Sub 시스템과 AsyncSemaphore를 활용하여 다음과 같은 방식으로 동작한다:</p>
 <details>
    <summary>Redisson tryLock() Code</summary>
       <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">   <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 1. 최초 락 획득 시도</span></span><br><span class="line">   Long ttl = <span class="keyword">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">   <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 2. 타이머 갱신 및 대기</span></span><br><span class="line">         time -= System.currentTimeMillis() - current;</span><br><span class="line">         <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 3. Pub/Sub 채널 구독</span></span><br><span class="line">            CompletableFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="keyword">this</span>.subscribe(threadId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               subscribeFuture.get(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException var21) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!subscribeFuture.completeExceptionally(<span class="keyword">new</span> RedisTimeoutException(<span class="string">&quot;Unable to acquire subscription lock after &quot;</span> + time + <span class="string">&quot;ms. Try to increase &#x27;subscriptionsPerConnection&#x27; and/or &#x27;subscriptionConnectionPoolSize&#x27; parameters.&quot;</span>))) &#123;</span><br><span class="line">                     subscribeFuture.whenComplete((res, ex) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.unsubscribe(res, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     &#125;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException var22) &#123;</span><br><span class="line">               ExecutionException e = var22;</span><br><span class="line">               LOGGER.error(e.getMessage(), e);</span><br><span class="line">               <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               time -= System.currentTimeMillis() - current;</span><br><span class="line">               <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                     <span class="keyword">boolean</span> var25 = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">return</span> var25;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">boolean</span> var16;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">                        ttl = <span class="keyword">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           var16 = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">return</span> var16;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                           var16 = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="keyword">return</span> var16;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 4. Latch 대기와 재시도</span></span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                           ((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           ((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture)).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                     &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                     var16 = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">return</span> var16;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 5. 구독 해제</span></span><br><span class="line">               <span class="keyword">this</span>.unsubscribe((RedissonLockEntry)<span class="keyword">this</span>.commandExecutor.getNow(subscribeFuture), threadId);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </details>

<p> <strong>1. 최초 락 획득 시도</strong></p>
<ul>
<li>tryAcquire 메서드를 통해 락 획득 가능 여부를 확인하며, null을 반환하면 현재 락을 바로 획득할 수 있음을 의미한다.</li>
<li>락이 이미 선점된 경우, ttl(잠금의 남은 유효 시간)을 반환하여 대기할 시간을 계산한다.</li>
</ul>
<p> <strong>2. 타이머 갱신 및 대기</strong></p>
<ul>
<li>대기 중 경과된 시간을 waitTime에서 차감하며 남은 시간이 0 이하일 경우 대기를 종료하고 false를 반환한다.</li>
</ul>
<p> <strong>3. Pub/Sub 채널 구독</strong></p>
<ul>
<li>락 해제 이벤트를 감지하기 위해 Redis Pub/Sub 채널에 구독을 요청한다.</li>
<li>subscribeFuture를 통해 락이 해제되었거나 구독에 실패한 경우 작업이 비동기적으로 처리된다.</li>
</ul>
<p> <strong>4. latch 대기와 재시도</strong></p>
<ul>
<li>Pub/Sub 채널 구독이 성공한 상태에서 tryAcquire를 반복 호출하며 락 획득을 재시도한다.</li>
<li>TTL 값에 따라 latch 대기 시간이 설정되며, 다른 스레드에서 락이 해제되면 latch가 해제되어 작업이 이어진다.</li>
</ul>
<p> <strong>5. 구독 해제</strong></p>
<ul>
<li>락을 획득하든 못 하든 메서드를 종료하기 전에 Pub/Sub 구독 리소스를 해제하여 시스템 자원을 정리한다.</li>
</ul>
</li>
</ul>
<p><strong>3.1. Redisson 적용 후 실험 결과:</strong></p>
<ul>
<li><p>2.1. 실험과 동일한 script와 wrk 명령어를 이용해 실험을 진행했으며, 다음과 같은 결과가 확인되었다.</p>
</li>
<li><img src="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/4.png" class></li>
<li><p><strong>실험 결과 요약:</strong></p>
<ul>
<li>Redisson을 사용하여 분산 락을 적용한 결과, 모든 요청이 순차적으로 처리되었으며 데이터의 무결성이 유지되었다.</li>
<li>로그에서 확인할 수 있듯이 동일한 자원에 대해 락이 적용되어 요청이 병렬적으로 처리되지 않고 순차적으로 처리되었다.</li>
<li>예를 들어, “User 1 자원 1 사용, 남은 자원: 9”에서 시작하여 요청이 처리될 때마다 자원이 정확히 감소하는 모습을 확인할 수 있었다.</li>
<li>실험 중에는 잘못된 자원 감소나 동시성 문제가 발생하지 않았다.</li>
</ul>
</li>
<li><p><strong>문제 해결 확인:</strong></p>
<ul>
<li>Redisson의 분산 락을 적용함으로써 동시성 문제로 인한 데이터 무결성 훼손이 해결되었다.</li>
<li>요청량이 많을 때에도 대기 상태로 처리되며 자원의 상태가 정확히 갱신되었다.</li>
</ul>
</li>
</ul>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><ul>
<li>테스트 결과<ul>
<li>Redisson 기반 분산 락을 적용한 후, 중복 트랜잭션 문제가 해결되었다.</li>
<li>부하 테스트(wrk)에서 동일한 유저의 데이터를 처리할 때, 데이터 무결성이 유지됨을 확인하였다.</li>
<li>이로써 분산 서버 환경에서 발생하던 자원 동시성 문제를 해결할 수 있었다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="논의"><a href="#논의" class="headerlink" title="논의"></a>논의</h2><p>Pub/Sub 기반 락 메커니즘은 성능과 자원 활용면에서 유리하며, 이를 사용하는 Redisson을 사용하여 분산 환경에서도 효율적으로 동시성 제어가 가능하지만,<br>Redis를 따로 구축하여야 한다는 점, Redis의 장애 시 락 메커니즘이 정상적으로 동작하지 않을 수 있다는 점과 락 해제 실패 또는 락 대기 시간 초과 시 추가적 오류 처리가 필요하다는 한계점 등이 존재한다.<br>해당 한계점들을 개선하기 위해 이후에 Redis Cluster를 활용해 고가용성을 확보하여야하고, Redis 외에 기타 다른 도구(Zookeeper, Etcd 등)와의 성능 비교가 필요하다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>본 글에서는 Redis와 Redisson을 활용한 분산 락 메커니즘을 통해 동시성 이슈를 해결하는 방법을 제시하였다.<br>실험 결과, 제안된 방법은 데이터 무결성을 효과적으로 유지하며, 부하 테스트에서도 우수한 성능을 보였다.<br>본 글이 분산 환경에서의 동시성 문제를 해결하려는 개발자들에게 실질적인 가이드라인을 제공하길 기대하며, 본 글에서 사용된 <code>tryLock()</code>의 내부 작동원리는 <a href="https://jungguji.github.io/2025/01/09/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-Redisson-tryLock-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC/">동시성 제어를 위한 Redisson tryLock 메서드의 작동 원리</a>에서 확인 할 수 있다.</p>

                    
                        


                    
                    
                        <p>
                            <a href="/2024/12/24/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EC%99%80-Redis-Redisson-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/#post-footer" class="postShorten-excerpt_link link" aria-label>
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Junggu Ji. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Junggu Ji</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-fvy43rs4ns3qkm3cliupi5qtnm0vwph13v4ev99f0qvrcz9tbdyatctmah0i.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
